"use client";

import { useState, useEffect, useRef } from "react";
import React from 'react';
import Link from "next/link";

// export const metadata = {
//   title: 'Next.js',
//   description: 'Generated by Next.js',
// }

function MapLoadingScreen({ onComplete }: { onComplete: () => void }) {
  const [progress, setProgress] = useState(0);
  const [fadeOut, setFadeOut] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const LOADING_DURATION = 1000; // 1 seconds

  // Blue AI Matrix rain effect
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    let animationFrameId: number;
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    const fontSize = 18;
    const columns = Math.floor(width / fontSize);
    const drops: number[] = Array(columns).fill(1);
    // AI/robotic glyphs: 0, 1, |, =, #, Latin, and some circuit-like unicode
    const chars = "01|=#AI人工智能ΣλΩµπβΓΔΞΦΨαβγδεζηθικλμνξοπρστυφχψωABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const blueShades = ["#38bdf8", "#0ea5e9", "#1e40af", "#60a5fa", "#2563eb"];

    function draw() {
      if (!ctx) return;
      ctx.fillStyle = "rgba(10, 20, 40, 0.18)";
      ctx.fillRect(0, 0, width, height);
      ctx.font = fontSize + "px monospace";
      for (let i = 0; i < drops.length; i++) {
        const text = chars[Math.floor(Math.random() * chars.length)];
        const color = blueShades[Math.floor(Math.random() * blueShades.length)];
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 8;
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);
        ctx.shadowBlur = 0;
        if (drops[i] * fontSize > height && Math.random() > 0.975) {
          drops[i] = 0;
        }
        drops[i]++;
      }
      animationFrameId = requestAnimationFrame(draw);
    }
    draw();
    function handleResize() {
      if (!canvas) return;
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    window.addEventListener('resize', handleResize);
    return () => {
      cancelAnimationFrame(animationFrameId);
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  // Loading bar progress
  useEffect(() => {
    const steps = 100;
    const intervalTime = LOADING_DURATION / steps;
    const interval = setInterval(() => {
      setProgress((prev) => {
        if (prev >= 100) {
          clearInterval(interval);
          return 100;
        }
        return Math.min(prev + 1, 100);
      });
    }, intervalTime);
    return () => clearInterval(interval);
  }, []);

  // Fade out and reveal
  useEffect(() => {
    if (progress >= 100) {
      setTimeout(() => {
        setFadeOut(true);
        setTimeout(() => {
          setIsLoading(false);
          onComplete();
        }, 700);
      }, 200);
    }
  }, [progress, onComplete]);

  if (!isLoading) return null;

  return (
    <div className={`fixed inset-0 z-50 flex items-center justify-center overflow-hidden ai-matrix-bg ${fadeOut ? 'ai-matrix-fade' : ''}`}> 
      <canvas ref={canvasRef} className="absolute inset-0 w-full h-full" style={{ display: 'block', zIndex: 1 }} />
      <div className="flex items-center justify-center w-full h-full relative z-10">
        <div
          className="ai-matrix-bar"
          style={{
            width: fadeOut ? '100vw' : `${Math.max(32, 4 * progress)}px`,
            height: 18,
            borderRadius: fadeOut ? 0 : 8,
            background: 'linear-gradient(90deg, #38bdf8 0%, #0ea5e9 60%, #1e40af 100%)',
            boxShadow: '0 0 24px 4px #38bdf8, 0 0 48px 12px #0ea5e9',
            border: '1.5px solid #60a5fa',
            transition: 'width 0.7s cubic-bezier(0.4,0,0.2,1), border-radius 0.7s cubic-bezier(0.4,0,0.2,1), opacity 0.7s',
            opacity: fadeOut ? 0 : 1,
            filter: 'drop-shadow(0 0 8px #38bdf8) drop-shadow(0 0 16px #0ea5e9)'
          }}
        />
      </div>
      <style jsx global>{`
        .ai-matrix-bg {
          background: #0a1428;
        }
        .ai-matrix-fade {
          transition: opacity 0.7s;
          opacity: 0;
        }
      `}</style>
    </div>
  );
}

function MapHeader() {
  const [showHome, setShowHome] = React.useState(true);

  React.useEffect(() => {
    const handleScroll = () => {
      setShowHome(window.scrollY < 50);
    };
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  return (
    <>
      {/* Floating Home Button (disappears on scroll) */}
      {showHome && (
        <a href="/" className="fixed top-6 left-6 z-50 bg-white/90 shadow-lg rounded-full p-3 hover:bg-cyan-100 transition-colors group">
          <svg
            className="h-7 w-7 text-blue-700 group-hover:text-cyan-600 transition-colors"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d="M3 11.5L12 5l9 6.5V19a2 2 0 01-2 2h-3.5a.5.5 0 01-.5-.5V15a1 1 0 00-1-1h-2a1 1 0 00-1 1v5.5a.5.5 0 01-.5.5H5a2 2 0 01-2-2v-7.5z"
            />
          </svg>
        </a>
      )}
      {/* Centered Floating Card Header */}
      <div className="w-full flex justify-center mt-6">
        <div className="backdrop-blur-md bg-white/90 shadow-lg rounded-2xl px-8 py-4 flex flex-col items-center max-w-2xl w-full mx-2">
          <h1 className="text-2xl font-bold text-blue-900 text-center">Africa AI Readiness Map</h1>
          <p className="text-sm text-blue-700/80 font-light mt-1 text-center">
            Explore artificial intelligence preparedness across African nations
          </p>
        </div>
      </div>
    </>
  );
}

export default function MapLayout({ children }: { children: React.ReactNode }) {
  const [showContent, setShowContent] = useState(false);
  const [hasChecked, setHasChecked] = useState(false);

  useEffect(() => {
    if (typeof window !== "undefined") {
      const alreadyLoaded = sessionStorage.getItem("mapPageLoadedOnce");
      if (!alreadyLoaded) {
        setShowContent(false);
      } else {
        setShowContent(true);
      }
      setHasChecked(true);
    }
  }, []);

  const handleLoadingComplete = () => {
    setShowContent(true);
    if (typeof window !== "undefined") {
      sessionStorage.setItem("mapPageLoadedOnce", "true");
    }
  };

  if (!hasChecked) return null;

  return (
    <>
      {!showContent && <MapLoadingScreen onComplete={handleLoadingComplete} />}
      {showContent && (
        <>
          <MapHeader />
          {children}
        </>
      )}
    </>
  );
}